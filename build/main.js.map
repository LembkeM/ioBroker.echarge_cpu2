{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.4.0\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\nimport EventEmitter from \"events\";\nimport { SaliaHttpService } from \"./saliahttpservice\";\nimport { DeviceInformation } from \"./types/DeviceInformation\";\nimport { Cp2, Metering, Salia } from \"./types/Root\";\n\nclass EchargeCpu2 extends utils.Adapter {\n    isOnlineCheckTimeout: any;\n    isCPStateCheckTimeout: any;\n\n    eventEmitter: EventEmitter;\n    saliaHttpService!: SaliaHttpService;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: \"echarge_cpu2\",\n        });\n        this.on(\"ready\", this.onReady.bind(this));\n        // this.on(\"stateChange\", this.onStateChange.bind(this));\n        // this.on(\"objectChange\", this.onObjectChange.bind(this));\n        // this.on(\"message\", this.onMessage.bind(this));\n        this.on(\"unload\", this.onUnload.bind(this));\n\n        this.eventEmitter = new EventEmitter();\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        if (!this.config.basicDeviceUrl) {\n            this.log.error(`Device Url is empty - please check instance configuration of ${this.namespace}`);\n            return;\n        }\n\n        try {\n            this.saliaHttpService = new SaliaHttpService({\n                baseURL: this.config.basicDeviceUrl,\n                log: this.log,\n                eventEmitter: this.eventEmitter,\n            });\n\n            // Handle Device changes to the connectionstate\n            this.eventEmitter.on(\n                \"onisOnlineChanged\",\n                async (isOnline: boolean) => await this.connectionStateChanged({ isOnline }),\n            );\n\n            // Handle Device changes to the connectionstate\n            this.eventEmitter.on(\n                \"onDeviceInformationRefreshed\",\n                async (deviceInformation: DeviceInformation) =>\n                    await this.DeviceInformationRefreshed({ deviceInfo: deviceInformation }),\n            );\n\n            // Handle Device changes to the connectionstate\n            this.eventEmitter.on(\n                \"onDeviceCPInformationRefreshed\",\n                async (deviceCPInformation: Cp2) => await this.deviceCPInformationCheck({ deviceCPInformation }),\n            );\n\n            this.eventEmitter.on(\n                \"onDeviceChargeDataRefreshed\",\n                async (deviceChargeData: Salia) =>\n                    await this.DeviceChargeDataRefreshed({ chargeData: deviceChargeData }),\n            );\n\n            this.eventEmitter.on(\n                \"onDeviceMeteringRefreshed\",\n                async (deviceMetering: Metering) => await this.deviceMeteringInformation({ deviceMetering }),\n            );\n\n            // Reset the Connectionstate\n            await this.setStateAsync(\"info.connection\", false, true);\n\n            // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n            // this.subscribeStates(\"testVariable\");\n            // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n            // this.subscribeStates(\"lights.*\");\n            // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n            // this.subscribeStates(\"*\");\n\n            /*\n\t\t\tsetState examples\n\t\t\tyou will notice that each setState will cause the stateChange event to fire (because of above subscribeStates cmd)\n\t\t*/\n            // the variable testVariable is set to true as command (ack=false)\n            // await this.setStateAsync(\"testVariable\", true);\n\n            // same thing, but the value is flagged \"ack\"\n            // ack should be always set to true if the value is received from or acknowledged from the target system\n            // await this.setStateAsync(\"testVariable\", { val: true, ack: true });\n\n            // same thing, but the state is deleted after 30s (getState will return null afterwards)\n            // await this.setStateAsync(\"testVariable\", { val: true, ack: true, expire: 30 });\n\n            // Start online check\n            this.saliaHttpService\n                .connect()\n                .then(() => {\n                    this.log.info(\"Connected\");\n                })\n                .catch((reason) => {\n                    this.log.error(`Connection failure: ${reason}`);\n                });\n        } catch (error: any) {\n            this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n        }\n\n        // examples for the checkPassword/checkGroup functions\n        // let result = await this.checkPasswordAsync(\"admin\", \"iobroker\");\n        // this.log.info(\"check user admin pw iobroker: \" + result);\n\n        // result = await this.checkGroupAsync(\"admin\", \"admin\");\n        // this.log.info(\"check group user admin group admin: \" + result);\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            // clearTimeout(timeout2);\n            // ...\n            // clearInterval(interval1);\n\n            this.saliaHttpService.stop();\n\n            callback();\n        } catch (error: any) {\n            this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    // \tif (obj) {\n    // \t\t// The object was changed\n    // \t\tthis.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    // \t} else {\n    // \t\t// The object was deleted\n    // \t\tthis.log.info(`object ${id} deleted`);\n    // \t}\n    // }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    // private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n    //     if (state && !state.ack) {\n    //         const stateId = id.replace(this.namespace + \".\", \"\");\n\n    //         // The state was changed\n    //         this.log.info(`state ${stateId} changed: ${state.val} (ack = ${state.ack})`);\n\n    //         await this.setStateAsync(stateId, state.val, true);\n    //     } else {\n    //         // The state was deleted\n    //         this.log.info(`state ${id} deleted`);\n    //     }\n    // }\n\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    // private onMessage(obj: ioBroker.Message): void {\n    // \tif (typeof obj === \"object\" && obj.message) {\n    // \t\tif (obj.command === \"send\") {\n    // \t\t\t// e.g. send email or pushover or whatever\n    // \t\t\tthis.log.info(\"send command\");\n\n    // \t\t\t// Send response in callback if required\n    // \t\t\tif (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n    // \t\t}\n    // \t}\n    // }\n\n    private async connectionStateChanged({ isOnline }: { isOnline: boolean }): Promise<void> {\n        await this.setStateAsync(\"info.connection\", isOnline, true);\n    }\n\n    private async DeviceChargeDataRefreshed({ chargeData }: { chargeData: Salia }): Promise<void> {\n        this.log.info(`${chargeData.chargedata}`);\n    }\n\n    private async DeviceInformationRefreshed({ deviceInfo }: { deviceInfo: DeviceInformation }): Promise<void> {\n        // if ((deviceInfoResponse as DeviceInformation) != null) {\n        //     const response = deviceInfoResponse as DeviceInformation;\n        //     this.log.debug(\"deviceInfoResponse: \" + response.hardware_version);\n\n        await this.setStateAsync(\"deviceInfo.hardware_version\", deviceInfo.hardware_version, true);\n        await this.setStateAsync(\"deviceInfo.hostname\", deviceInfo.hostname, true);\n        await this.setStateAsync(\"deviceInfo.internal_id\", deviceInfo.internal_id, true);\n        await this.setStateAsync(\"deviceInfo.mac_address\", deviceInfo.mac_address, true);\n        await this.setStateAsync(\"deviceInfo.product\", deviceInfo.product, true);\n        await this.setStateAsync(\"deviceInfo.serial\", deviceInfo.serial, true);\n        await this.setStateAsync(\"deviceInfo.software_version\", deviceInfo.software_version, true);\n        await this.setStateAsync(\"deviceInfo.vcs_version\", deviceInfo.vcs_version, true);\n        // } else {\n        //     const response = deviceInfoResponse as ApiError;\n\n        //     this.log.error(response.message);\n        // }\n    }\n\n    private async deviceCPInformationCheck({ deviceCPInformation }: { deviceCPInformation: Cp2 }): Promise<void> {\n        await this.setStateAsync(\"deviceSecc.scc_cp_state\", deviceCPInformation.state, true);\n    }\n\n    private async deviceMeteringInformation({ deviceMetering }: { deviceMetering: Metering }): Promise<void> {\n        await this.setStateAsync(\"deviceSecc.metering.meter.available\", +deviceMetering.meter.available, true);\n\n        await this.setStateAsync(\n            \"deviceSecc.metering.energy.active_total.actual\",\n            +deviceMetering.energy.active_total.actual / 10,\n            true,\n        );\n\n        await this.setStateAsync(\n            \"deviceSecc.metering.power.active_total.actual\",\n            +deviceMetering.power.active_total.actual / 10,\n            true,\n        );\n\n        await this.setStateAsync(\n            \"deviceSecc.metering.power.active.ac.l1_actual\",\n            +deviceMetering.power.active.ac.l1.actual,\n            true,\n        );\n        await this.setStateAsync(\n            \"deviceSecc.metering.power.active.ac.l2_actual\",\n            +deviceMetering.power.active.ac.l2.actual,\n            true,\n        );\n        await this.setStateAsync(\n            \"deviceSecc.metering.power.active.ac.l3_actual\",\n            +deviceMetering.power.active.ac.l3.actual,\n            true,\n        );\n\n        await this.setStateAsync(\n            \"deviceSecc.metering.current.ac.l1_actual\",\n            +deviceMetering.current.ac.l1.actual,\n            true,\n        );\n        await this.setStateAsync(\n            \"deviceSecc.metering.current.ac.l2_actual\",\n            +deviceMetering.current.ac.l2.actual,\n            true,\n        );\n        await this.setStateAsync(\n            \"deviceSecc.metering.current.ac.l3_actual\",\n            +deviceMetering.current.ac.l3.actual,\n            true,\n        );\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new EchargeCpu2(options);\n} else {\n    // otherwise start the instance directly\n    (() => new EchargeCpu2())();\n}\n"],
  "mappings": "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",
  "names": ["EventEmitter"]
}
