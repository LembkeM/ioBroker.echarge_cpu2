{
  "version": 3,
  "sources": ["../src/salia-helper.ts"],
  "sourcesContent": ["import { ping } from \"@network-utils/tcp-ping\";\nimport axios, { AxiosInstance } from \"axios\";\nimport EventEmitter from \"events\";\nimport https from \"https\";\nimport { DeviceCPInformation } from \"./types/DeviceCPInformation\";\nimport { DeviceInformation } from \"./types/DeviceInformation\";\nimport { Metering } from \"./types/Root\";\n\ninterface CancellableSleep {\n    promise: Promise<void>;\n    cancel(reason?: any): void;\n}\n\nexport class SaliaHttpClient {\n    private readonly instance: AxiosInstance;\n    private readonly log: ioBroker.Logger;\n    private readonly eventEmitter: EventEmitter;\n\n    private timeout?: CancellableSleep;\n\n    private deviceUrl!: URL;\n    private devicePort!: number;\n\n    private deviceStatus: boolean;\n\n    public constructor(options: { baseURL: string; log: ioBroker.Logger; eventEmitter: EventEmitter }) {\n        this.log = options.log;\n\n        this.eventEmitter = options.eventEmitter;\n\n        this.deviceUrl = new URL(options.baseURL);\n\n        this.deviceStatus = false;\n\n        if (this.deviceUrl.port == \"\") {\n            this.devicePort = 443;\n        } else {\n            this.devicePort = parseInt(this.deviceUrl.port);\n        }\n\n        const baseURL: string = options.baseURL;\n\n        this.instance = axios.create({\n            baseURL,\n            timeout: 1000,\n            responseType: \"json\",\n            responseEncoding: \"utf8\",\n            httpsAgent: new https.Agent({\n                rejectUnauthorized: false,\n            }),\n        });\n    }\n\n    public async connect(): Promise<void> {\n        while (true) {\n            try {\n                // try to connect somethere\n                this.log.debug(\"Connection attempt\");\n\n                await this.onlineCheck();\n\n                if (this.deviceStatus) {\n                    await this.getDeviceInfos();\n                    await this.getDeviceCPInformation();\n\n                    await this.getDeviceMetering();\n                }\n                return Promise.resolve();\n            } catch (e) {\n                if (e instanceof Error) {\n                    this.log.error(e.message);\n                }\n\n                this.timeout = this.cancellableSleep(1000);\n                await this.timeout.promise;\n            }\n        }\n    }\n\n    public stop(): void {\n        this.timeout?.cancel(\"Connection is no longer needed.\");\n        this.timeout = undefined;\n    }\n\n    private cancellableSleep(ms: number): CancellableSleep {\n        let timer: NodeJS.Timeout;\n        let rejectPromise: (reason?: unknown) => void;\n\n        const promise = new Promise<void>((resolve, reject) => {\n            timer = global.setTimeout(() => resolve(), ms);\n            rejectPromise = reject;\n        });\n\n        return {\n            cancel: (reason?: unknown) => {\n                global.clearTimeout(timer);\n                rejectPromise(reason || new Error(\"Timeout cancelled\"));\n            },\n            promise,\n        };\n    }\n\n    private async onlineCheck(): Promise<void> {\n        let deviceStatus = false;\n        try {\n            const hostReachable = await ping({ address: this.deviceUrl.hostname, port: this.devicePort, timeout: 500 });\n\n            if (hostReachable.errors.length == 0) {\n                deviceStatus = true;\n            }\n        } catch (error: any) {\n            this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n        }\n\n        if (this.deviceStatus != deviceStatus) {\n            this.deviceStatus = deviceStatus;\n            this.eventEmitter.emit(\"onisOnlineChanged\", this.deviceStatus);\n        }\n    }\n\n    private getDeviceInfos = async (): Promise<void> => {\n        try {\n            const { data } = await this.instance.get<DeviceInformation>(\"/api/device\");\n\n            this.eventEmitter.emit(\"onDeviceInformationRefreshed\", data);\n        } catch (error: any) {\n            this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n        }\n    };\n\n    private getDeviceCPInformation = async (): Promise<void> => {\n        try {\n            const { data } = await this.instance.get<DeviceCPInformation>(\"/api/secc/port0/cp\");\n\n            // Zustand A (12V): Fahrzeug nicht angeschlossen und nicht ladebereit\n            // Zustand B (9V/-12V): Fahrzeug angeschlossen, aber nicht ladebereit\n            // Zustand C (6V/-12V): Fahrzeug angeschlossen und ladebereit\n            // Zustand D (3V/-12V): L\u00FCftungsanforderung\n            // Zustand E (0V): Fehlerzustand \u201CKurzschluss\u201D (CP-PE \u00FCber Diode)\n            // Zustand F (-): Fehlerzustand \u201CWallbox-Ausfall, keine Verbindung\u201D\n\n            this.eventEmitter.emit(\"onDeviceCPInformationRefreshed\", data);\n        } catch (error: any) {\n            this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n        }\n    };\n\n    private getDeviceMetering = async (): Promise<void> => {\n        await this.instance\n            .get<Metering>(\"/api/secc/port0/metering\")\n            .then((resp) => {\n                this.log.debug(JSON.stringify(resp.data));\n\n                this.eventEmitter.emit(\"onDeviceMeteringRefreshed\", resp.data);\n            })\n            .catch((error) => {\n                this.log.error(`[onReady] error: ${error.message}, stack: ${error.stack}`);\n            });\n    };\n}\n"],
  "mappings": "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",
  "names": ["axios", "https"]
}
